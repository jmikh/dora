"""
SQLAlchemy models for Noom reviews database
"""

from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean, ForeignKey, create_engine
from sqlalchemy.orm import declarative_base, relationship, Session
from pathlib import Path
from datetime import datetime

Base = declarative_base()

# Database file path
DB_FILE = Path(__file__).parent / "dora.db"
DATABASE_URL = f"sqlite:///{DB_FILE}"


class Review(Base):
    """Review model - represents reviews table"""
    __tablename__ = "reviews"

    review_id = Column(Text, primary_key=True, nullable=False)
    company_id = Column(Integer, ForeignKey("companies.id"), nullable=False)  # Foreign key to companies
    source = Column(Text, nullable=True)  # Source of the review (playstore, appstore, trustpilot, etc.)
    user_name = Column(Text)
    rating = Column(Integer, nullable=False)
    helpful_votes = Column(Integer, default=0)
    date = Column(DateTime, nullable=False)
    review_text = Column(Text)
    reply_content = Column(Text)
    version = Column(Text)
    generated_insights = Column(Boolean, default=False)  # Whether insights have been extracted
    sentiment_score = Column(Integer, nullable=True)  # 1-5 sentiment score from AI extraction (compare to rating)
    ai_processed = Column(Boolean, default=False)  # DEPRECATED: Use complaints_processed and use_cases_processed instead
    complaints_processed = Column(Boolean, default=False)  # Whether complaints have been extracted
    use_cases_processed = Column(Boolean, default=False)  # Whether use cases have been extracted

    # Relationship
    company = relationship("Company")

    def __repr__(self):
        return f"<Review(company_id={self.company_id}, id={self.review_id[:8]}, rating={self.rating})>"


class Cluster(Base):
    """Cluster model - represents clusters table"""
    __tablename__ = "clusters"

    id = Column(Integer, primary_key=True, autoincrement=True)
    company_name = Column(Text, nullable=False)  # Company this cluster is for
    insight_type = Column(Text, nullable=True)  # DEPRECATED: Use cluster_type instead
    cluster_type = Column(Text, nullable=False, default="complaints")  # 'complaints' or 'use_cases'
    embedding_type = Column(Text, nullable=False)  # 'original' or 'reduced'
    n_components = Column(Integer, nullable=True)  # Dimension count for reduced embeddings
    cluster_label = Column(Text, nullable=True)  # 2-3 word label (generated by LLM)
    cluster_summary = Column(Text, nullable=True)  # Summary sentence (generated by LLM)
    size = Column(Integer, nullable=False)  # Number of insights in cluster
    created_at = Column(DateTime, nullable=False, default=datetime.now)

    def __repr__(self):
        label = self.cluster_label or "unlabeled"
        return f"<Cluster(company={self.company_name}, id={self.id}, label={label}, size={self.size})>"


class ClusterGroup(Base):
    """Cluster group model - represents semantic groups of clusters"""
    __tablename__ = "cluster_groups"

    id = Column(Integer, primary_key=True, autoincrement=True)
    company_name = Column(Text, nullable=False)  # Company this group is for
    insight_type = Column(Text, nullable=False)  # 'pain_point', 'feature_request', 'use_case'
    embedding_type = Column(Text, nullable=False)  # 'original' or 'reduced'
    n_components = Column(Integer, nullable=True)  # Dimension count for reduced embeddings
    group_name = Column(Text, nullable=False)  # 3-5 word group name (e.g., "Pricing & Value Concerns")
    group_description = Column(Text, nullable=False)  # One sentence description
    created_at = Column(DateTime, nullable=False, default=datetime.now)

    # Relationship to cluster assignments
    cluster_assignments = relationship("ClusterGroupAssignment", back_populates="group")

    def __repr__(self):
        return f"<ClusterGroup(company={self.company_name}, id={self.id}, name={self.group_name})>"


class ClusterGroupAssignment(Base):
    """Association table linking clusters to groups"""
    __tablename__ = "cluster_group_assignments"

    id = Column(Integer, primary_key=True, autoincrement=True)
    group_id = Column(Integer, ForeignKey("cluster_groups.id"), nullable=False)
    cluster_id = Column(Integer, ForeignKey("clusters.id"), nullable=False)

    # Relationships
    group = relationship("ClusterGroup", back_populates="cluster_assignments")
    cluster = relationship("Cluster")

    def __repr__(self):
        return f"<ClusterGroupAssignment(group_id={self.group_id}, cluster_id={self.cluster_id})>"


class YouTubeVideo(Base):
    """YouTube video model"""
    __tablename__ = "youtube_videos"

    # Primary key
    id = Column(String, primary_key=True, nullable=False)  # YouTube video ID

    # Company association
    company_name = Column(Text, nullable=False, default='wispr')  # Company this video is about

    # Basic video info
    title = Column(Text, nullable=False)
    translated_title = Column(Text, nullable=True)
    type = Column(String, nullable=True)  # 'video', 'short', etc.
    url = Column(Text, nullable=False)
    thumbnail_url = Column(Text, nullable=True)

    # Metrics
    view_count = Column(Integer, default=0)
    likes = Column(Integer, default=0)
    comments_count = Column(Integer, default=0)

    # Dates
    date = Column(DateTime, nullable=False)  # Upload/publish date

    # Channel info
    channel_name = Column(Text, nullable=True)
    channel_url = Column(Text, nullable=True)
    channel_username = Column(Text, nullable=True)
    channel_id = Column(String, nullable=True)
    number_of_subscribers = Column(Integer, default=0)

    # Content
    duration = Column(String, nullable=True)  # Format: "00:01:26"
    text = Column(Text, nullable=True)  # Description text
    translated_text = Column(Text, nullable=True)

    # Subtitles (flattened - taking first subtitle if available)
    subtitle_type = Column(String, nullable=True)  # 'auto_generated' or 'manual'
    subtitle_language = Column(String, nullable=True)
    subtitle_srt = Column(Text, nullable=True)  # Full SRT content

    # Metadata
    location = Column(Text, nullable=True)
    collaborators = Column(Text, nullable=True)
    order = Column(Integer, nullable=True)
    comments_turned_off = Column(Boolean, default=False)
    from_yt_url = Column(Text, nullable=True)
    is_monetized = Column(Boolean, nullable=True)
    hashtags = Column(Text, nullable=True)  # JSON array as string
    is_members_only = Column(Boolean, default=False)
    input_query = Column(Text, nullable=True)  # Search query used

    def __repr__(self):
        return f"<YouTubeVideo(id={self.id}, title={self.title[:50]}...)>"


class Company(Base):
    """Company model - represents companies for multi-tenant support"""
    __tablename__ = "companies"

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(Text, nullable=False, unique=True)  # 'wispr', 'noom', etc.
    image_url = Column(Text, nullable=True)  # Company logo/icon URL
    created_at = Column(DateTime, nullable=False, default=datetime.now)

    def __repr__(self):
        return f"<Company(id={self.id}, name={self.name})>"


class RedditCommunity(Base):
    """Reddit community (subreddit) model"""
    __tablename__ = "reddit_communities"

    # Primary key
    id = Column(String, primary_key=True, nullable=False)  # Reddit ID like 'ckro6f'

    # Foreign key to company
    company_id = Column(Integer, ForeignKey("companies.id"), nullable=False)

    # Subreddit info
    name = Column(Text, nullable=True)  # Internal name like 't5_ckro6f'
    display_name = Column(Text, nullable=True)  # Display name like 'WisprFlow'
    title = Column(Text, nullable=True)
    description = Column(Text, nullable=True)
    categories = Column(Text, nullable=True)

    # Metrics
    number_of_members = Column(Integer, default=0)

    # Flags
    over18 = Column(Boolean, default=False)

    # Media
    header_image = Column(Text, nullable=True)

    # URL
    url = Column(Text, nullable=True)

    # Timestamps
    created_at = Column(DateTime, nullable=True)
    scraped_at = Column(DateTime, nullable=True)

    # Relationship
    company = relationship("Company")

    def __repr__(self):
        return f"<RedditCommunity(id={self.id}, display_name={self.display_name})>"


class CompetitorMention(Base):
    """Competitor mention model - tracks competitors mentioned across all sources"""
    __tablename__ = "competitor_mentions"

    id = Column(Integer, primary_key=True, autoincrement=True)
    competitor_name = Column(Text, nullable=False)  # Name of competitor (e.g., "Spokenly", "Superwhisper")
    source_id = Column(String, nullable=False)  # ID of the source content (e.g., "t3_xyz" for Reddit, review_id for reviews)
    source_table = Column(String, nullable=False)  # Source table name (e.g., "reddit_content", "reviews", "youtube_videos")
    extracted_at = Column(DateTime, nullable=False, default=datetime.now)

    def __repr__(self):
        return f"<CompetitorMention(competitor={self.competitor_name}, source={self.source_table}, source_id={self.source_id[:10]}...)>"


class Complaint(Base):
    """Complaint model - tracks complaints extracted from all sources"""
    __tablename__ = "complaints"

    id = Column(Integer, primary_key=True, autoincrement=True)
    complaint = Column(Text, nullable=False)  # Short, normalized complaint text (e.g., "No local model support")
    quote = Column(Text, nullable=False)  # Exact quote from source content
    source_id = Column(String, nullable=False)  # ID of the source content (e.g., "t3_xyz" for Reddit, review_id for reviews)
    source_table = Column(String, nullable=False)  # Source table name (e.g., "reddit_content", "reviews", "youtube_videos")
    extracted_at = Column(DateTime, nullable=False, default=datetime.now)

    def __repr__(self):
        return f"<Complaint(complaint={self.complaint[:30]}..., source={self.source_table}, source_id={self.source_id[:10]}...)>"


class UseCase(Base):
    """UseCase model - tracks use cases extracted from all sources"""
    __tablename__ = "use_cases"

    id = Column(Integer, primary_key=True, autoincrement=True)
    use_case = Column(Text, nullable=False)  # Short, atomic use case (e.g., "Writing emails", "Dictating while driving")
    quote = Column(Text, nullable=False)  # Exact quote from source content
    source_id = Column(String, nullable=False)  # ID of the source content (e.g., "t3_xyz" for Reddit, review_id for reviews)
    source_table = Column(String, nullable=False)  # Source table name (e.g., "reddit_content", "reviews")
    extracted_at = Column(DateTime, nullable=False, default=datetime.now)

    def __repr__(self):
        return f"<UseCase(use_case={self.use_case[:30]}..., source={self.source_table}, source_id={self.source_id[:10]}...)>"


class ComplaintEmbedding(Base):
    """Complaint embedding model - stores embeddings for complaints at various dimensions"""
    __tablename__ = "complaint_embeddings"

    id = Column(Integer, primary_key=True, autoincrement=True)
    complaint_id = Column(Integer, ForeignKey("complaints.id"), nullable=False)
    complaint_text = Column(Text, nullable=False)  # Denormalized for convenience
    dimensions = Column(Integer, nullable=False)  # 1536 (full), 50, or 20 (reduced)
    embedding = Column(Text, nullable=False)  # JSON array of floats
    created_at = Column(DateTime, nullable=False, default=datetime.now)

    # Relationship
    complaint = relationship("Complaint")

    def __repr__(self):
        return f"<ComplaintEmbedding(id={self.id}, complaint_id={self.complaint_id}, dimensions={self.dimensions})>"


class UseCaseEmbedding(Base):
    """Use case embedding model - stores embeddings for use cases at various dimensions"""
    __tablename__ = "use_case_embeddings"

    id = Column(Integer, primary_key=True, autoincrement=True)
    use_case_id = Column(Integer, ForeignKey("use_cases.id"), nullable=False)
    use_case_text = Column(Text, nullable=False)  # Denormalized for convenience
    dimensions = Column(Integer, nullable=False)  # 1536 (full), 50, or 20 (reduced)
    embedding = Column(Text, nullable=False)  # JSON array of floats
    created_at = Column(DateTime, nullable=False, default=datetime.now)

    # Relationship
    use_case = relationship("UseCase")

    def __repr__(self):
        return f"<UseCaseEmbedding(id={self.id}, use_case_id={self.use_case_id}, dimensions={self.dimensions})>"


class RedditContent(Base):
    """Unified Reddit content model (posts and comments)"""
    __tablename__ = "reddit_content"

    # Primary key
    id = Column(String, primary_key=True, nullable=False)  # Reddit ID (t3_* for posts, t1_* for comments)

    # Foreign key to company
    company_id = Column(Integer, ForeignKey("companies.id"), nullable=False)

    # Content type
    content_type = Column(String, nullable=False)  # 'post' or 'comment'

    # Identifiers
    parsed_id = Column(String, nullable=True)

    # Content - Common fields
    body = Column(Text, nullable=True)
    username = Column(Text, nullable=True)
    user_id = Column(String, nullable=True)
    community_name = Column(Text, nullable=True)
    parsed_community_name = Column(Text, nullable=True)
    up_votes = Column(Integer, default=0)
    url = Column(Text, nullable=True)

    # Timestamps
    created_at = Column(DateTime, nullable=True)
    scraped_at = Column(DateTime, nullable=True)

    # Post-specific fields (NULL for comments)
    title = Column(Text, nullable=True)
    number_of_comments = Column(Integer, nullable=True)
    up_vote_ratio = Column(String, nullable=True)
    is_ad = Column(Boolean, nullable=True)
    is_video = Column(Boolean, nullable=True)
    over18 = Column(Boolean, nullable=True)
    flair = Column(Text, nullable=True)
    thumbnail_url = Column(Text, nullable=True)
    image_urls = Column(Text, nullable=True)
    link = Column(Text, nullable=True)

    # Comment-specific fields (NULL for posts)
    parent_id = Column(String, ForeignKey("reddit_content.id"), nullable=True)  # Self-reference!
    post_id = Column(String, ForeignKey("reddit_content.id"), nullable=True)  # References parent post
    number_of_replies = Column(Integer, nullable=True)
    category = Column(Text, nullable=True)

    # AI-extracted insights
    sentiment_score = Column(Integer, nullable=True)  # 1-5 sentiment score from AI extraction (null if not about Wispr)
    ai_processed = Column(Boolean, default=False)  # DEPRECATED: Use complaints_processed and use_cases_processed instead
    complaints_processed = Column(Boolean, default=False)  # Whether complaints have been extracted
    use_cases_processed = Column(Boolean, default=False)  # Whether use cases have been extracted

    # Relationships
    company = relationship("Company")
    parent_content = relationship("RedditContent", remote_side=[id], foreign_keys=[parent_id], backref="replies")
    post = relationship("RedditContent", remote_side=[id], foreign_keys=[post_id], backref="comments")

    def __repr__(self):
        if self.content_type == 'post':
            return f"<RedditContent(id={self.id}, type=post, title={self.title[:30] if self.title else 'N/A'}...)>"
        else:
            return f"<RedditContent(id={self.id}, type=comment, post_id={self.post_id})>"


def get_engine():
    """Create and return SQLAlchemy engine"""
    return create_engine(DATABASE_URL, echo=False)


def get_session() -> Session:
    """Create and return a new session"""
    engine = get_engine()
    return Session(engine)
