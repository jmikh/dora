"""
SQLAlchemy models for Noom reviews database
"""

from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean, ForeignKey, create_engine
from sqlalchemy.orm import declarative_base, relationship, Session
from pathlib import Path
from datetime import datetime

Base = declarative_base()

# Database file path
DB_FILE = Path(__file__).parent / "noom_playstore_reviews.db"
DATABASE_URL = f"sqlite:///{DB_FILE}"


class Review(Base):
    """Review model - represents reviews table"""
    __tablename__ = "reviews"

    review_id = Column(Text, primary_key=True, nullable=False)
    company_name = Column(Text, nullable=False)  # Company this review is for
    source = Column(Text, nullable=True)  # Source of the review (playstore, appstore, trustpilot, etc.)
    user_name = Column(Text)
    rating = Column(Integer, nullable=False)
    helpful_votes = Column(Integer, default=0)
    date = Column(DateTime, nullable=False)
    review_text = Column(Text)
    reply_content = Column(Text)
    version = Column(Text)
    generated_insights = Column(Boolean, default=False)  # Whether insights have been extracted

    # Relationship to insights
    insights = relationship("Insight", back_populates="review")

    def __repr__(self):
        return f"<Review(company={self.company_name}, id={self.review_id[:8]}, rating={self.rating})>"


class Insight(Base):
    """Insight model - represents insights table"""
    __tablename__ = "insights"

    id = Column(Integer, primary_key=True, autoincrement=True)
    review_id = Column(Text, ForeignKey("reviews.review_id"), nullable=True)  # Nullable for backward compatibility
    company_name = Column(Text, nullable=False)  # Company this insight is for
    insight_text = Column(Text, nullable=False)
    insight_type = Column(Text, nullable=False)  # 'pain_point', 'feature_request', 'praise', 'use_case'
    review_date = Column(DateTime, nullable=False)  # Date of source content (review date or video upload date)
    extracted_at = Column(DateTime, nullable=False)
    embedding = Column(Text, nullable=True)  # JSON string of embedding vector
    cluster_id = Column(Integer, ForeignKey("clusters.id"), nullable=True)  # Cluster assignment

    # Polymorphic source fields
    source_type = Column(Text, nullable=False, default='review')  # 'review' or 'youtube_video'
    source_id = Column(Text, nullable=False)  # ID of the source (review_id or video_id)

    # Relationship to review (optional, for backward compatibility)
    review = relationship("Review", back_populates="insights")
    # Relationship to cluster
    cluster = relationship("Cluster", back_populates="insights")

    def __repr__(self):
        return f"<Insight(company={self.company_name}, type={self.insight_type}, source={self.source_type}, text={self.insight_text[:30]}...)>"


class Cluster(Base):
    """Cluster model - represents clusters table"""
    __tablename__ = "clusters"

    id = Column(Integer, primary_key=True, autoincrement=True)
    company_name = Column(Text, nullable=False)  # Company this cluster is for
    insight_type = Column(Text, nullable=False)  # 'pain_point', 'feature_request', 'praise'
    embedding_type = Column(Text, nullable=False)  # 'original' or 'reduced'
    n_components = Column(Integer, nullable=True)  # Dimension count for reduced embeddings
    cluster_label = Column(Text, nullable=True)  # 2-3 word label (generated by LLM)
    cluster_summary = Column(Text, nullable=True)  # Summary sentence (generated by LLM)
    size = Column(Integer, nullable=False)  # Number of insights in cluster
    created_at = Column(DateTime, nullable=False, default=datetime.now)

    # Relationship to insights
    insights = relationship("Insight", back_populates="cluster")

    def __repr__(self):
        label = self.cluster_label or "unlabeled"
        return f"<Cluster(company={self.company_name}, id={self.id}, label={label}, size={self.size})>"


class ClusterGroup(Base):
    """Cluster group model - represents semantic groups of clusters"""
    __tablename__ = "cluster_groups"

    id = Column(Integer, primary_key=True, autoincrement=True)
    company_name = Column(Text, nullable=False)  # Company this group is for
    insight_type = Column(Text, nullable=False)  # 'pain_point', 'feature_request', 'use_case'
    embedding_type = Column(Text, nullable=False)  # 'original' or 'reduced'
    n_components = Column(Integer, nullable=True)  # Dimension count for reduced embeddings
    group_name = Column(Text, nullable=False)  # 3-5 word group name (e.g., "Pricing & Value Concerns")
    group_description = Column(Text, nullable=False)  # One sentence description
    created_at = Column(DateTime, nullable=False, default=datetime.now)

    # Relationship to cluster assignments
    cluster_assignments = relationship("ClusterGroupAssignment", back_populates="group")

    def __repr__(self):
        return f"<ClusterGroup(company={self.company_name}, id={self.id}, name={self.group_name})>"


class ClusterGroupAssignment(Base):
    """Association table linking clusters to groups"""
    __tablename__ = "cluster_group_assignments"

    id = Column(Integer, primary_key=True, autoincrement=True)
    group_id = Column(Integer, ForeignKey("cluster_groups.id"), nullable=False)
    cluster_id = Column(Integer, ForeignKey("clusters.id"), nullable=False)

    # Relationships
    group = relationship("ClusterGroup", back_populates="cluster_assignments")
    cluster = relationship("Cluster")

    def __repr__(self):
        return f"<ClusterGroupAssignment(group_id={self.group_id}, cluster_id={self.cluster_id})>"


class YouTubeVideo(Base):
    """YouTube video model"""
    __tablename__ = "youtube_videos"

    # Primary key
    id = Column(String, primary_key=True, nullable=False)  # YouTube video ID

    # Company association
    company_name = Column(Text, nullable=False, default='wispr')  # Company this video is about

    # Basic video info
    title = Column(Text, nullable=False)
    translated_title = Column(Text, nullable=True)
    type = Column(String, nullable=True)  # 'video', 'short', etc.
    url = Column(Text, nullable=False)
    thumbnail_url = Column(Text, nullable=True)

    # Metrics
    view_count = Column(Integer, default=0)
    likes = Column(Integer, default=0)
    comments_count = Column(Integer, default=0)

    # Dates
    date = Column(DateTime, nullable=False)  # Upload/publish date

    # Channel info
    channel_name = Column(Text, nullable=True)
    channel_url = Column(Text, nullable=True)
    channel_username = Column(Text, nullable=True)
    channel_id = Column(String, nullable=True)
    number_of_subscribers = Column(Integer, default=0)

    # Content
    duration = Column(String, nullable=True)  # Format: "00:01:26"
    text = Column(Text, nullable=True)  # Description text
    translated_text = Column(Text, nullable=True)

    # Subtitles (flattened - taking first subtitle if available)
    subtitle_type = Column(String, nullable=True)  # 'auto_generated' or 'manual'
    subtitle_language = Column(String, nullable=True)
    subtitle_srt = Column(Text, nullable=True)  # Full SRT content

    # Metadata
    location = Column(Text, nullable=True)
    collaborators = Column(Text, nullable=True)
    order = Column(Integer, nullable=True)
    comments_turned_off = Column(Boolean, default=False)
    from_yt_url = Column(Text, nullable=True)
    is_monetized = Column(Boolean, nullable=True)
    hashtags = Column(Text, nullable=True)  # JSON array as string
    is_members_only = Column(Boolean, default=False)
    input_query = Column(Text, nullable=True)  # Search query used

    def __repr__(self):
        return f"<YouTubeVideo(id={self.id}, title={self.title[:50]}...)>"


def get_engine():
    """Create and return SQLAlchemy engine"""
    return create_engine(DATABASE_URL, echo=False)


def get_session() -> Session:
    """Create and return a new session"""
    engine = get_engine()
    return Session(engine)
